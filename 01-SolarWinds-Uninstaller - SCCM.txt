<#
  Uninstall-SolarWinds_SCCM.ps1
  - Quiet mode for SCCM: prints a single summary line at the end
  - Parameter hardening: validates inputs and constrains TranscriptPath
  - NEVER reboots; treats 3010 as success
  - Order: Uninstall FIRST -> filesystem cleanup -> CertLM("SolarWinds Agent\Certificates") cleanup
  - Deletes ONLY the contents (certificates) from the "SolarWinds Agent" store; the store container remains
  - Exit codes: 0=success, 2=success with leftovers, 1=fatal
#>

[CmdletBinding()]
param(
  # SCCM passes strings -> prefer [bool] over [switch]
  [bool]$StrictCleanup = $true,       # True = exit 2 if leftovers remain; False = ignore leftovers
  [string]$TranscriptPath             # Optional; if empty, transcript is disabled
)

# ---------------- Parameter Hardening / Validation ----------------
# Coerce StrictCleanup if SCCM passed "True"/"False" as string
if ($PSBoundParameters.ContainsKey('StrictCleanup') -and ($StrictCleanup -isnot [bool])) {
  try { $StrictCleanup = [bool]::Parse("$StrictCleanup") } catch { $StrictCleanup = $true }
}

# Allow only these roots for the transcript file
$AllowedRoots = @('C:\Windows\Temp\', 'C:\Logs\')

function Test-PathUnderAllowedRoot {
  param([string]$Path, [string[]]$Roots)
  try {
    if ([string]::IsNullOrWhiteSpace($Path)) { return $false }
    # Reject wildcards / illegal chars
    if ($Path -match '[\*\?\|<>"]') { return $false }
    # Must be drive-rooted file ending in .log or .txt
    if ($Path -notmatch '^[A-Za-z]:\\[\w\-\.\s\\]+?\.(log|txt)$') { return $false }
    $full = [System.IO.Path]::GetFullPath($Path)
    foreach ($r in $Roots) {
      $rootNorm = [System.IO.Path]::GetFullPath($r)
      if ($full.StartsWith($rootNorm, [System.StringComparison]::OrdinalIgnoreCase)) { return $true }
    }
    return $false
  } catch { return $false }
}

if ($TranscriptPath) {
  if (-not (Test-PathUnderAllowedRoot -Path $TranscriptPath -Roots $AllowedRoots)) {
    throw "Invalid TranscriptPath. Use a .log or .txt under: $($AllowedRoots -join ', ')"
  }
  # Ensure parent directory exists
  $dir = [System.IO.Path]::GetDirectoryName($TranscriptPath)
  if (-not (Test-Path $dir)) { New-Item -Path $dir -ItemType Directory -Force | Out-Null }
}
# ---------------- End Validation ----------------

$ErrorActionPreference = 'Stop'
$ExitCode        = 0         # 0=success, 2=leftovers, 1=fatal
$RemovedCerts    = 0
$LeftoverDirs    = @()
$StoreLeft       = 0
$FoundTargets    = @()

# Folders to remove entirely. Comment out lines if you want to preserve them.
$GeneralPaths = @(
  'C:\Program Files\SolarWinds',
  'C:\Program Files (x86)\SolarWinds',
  'C:\ProgramData\SolarWinds',
  'C:\ProgramData\SolarWinds Agent',
  'C:\ProgramData\SolarWinds\Agent'
)

# Filesystem certificate folders: delete CONTENTS only (do not remove the folder itself)
$CertFoldersFS = @(
  'C:\ProgramData\SolarWinds\Agent\Certificates',
  'C:\ProgramData\SolarWinds Agent\Certificates',
  'C:\ProgramData\SolarWindsAgent\Certificates',
  'C:\ProgramData\SolarWinds Agente\Certificates',
  'C:\ProgramData\SolarWinds Agente\Certific*'
)

# Optional transcript (quiet mode: no chatter besides final line)
if ($TranscriptPath) { try { Start-Transcript -Path $TranscriptPath -Force | Out-Null } catch {} }

try {
  # 1) Stop services (quiet)
  Get-Service -ErrorAction SilentlyContinue | Where-Object {
    $_.Name -like 'SolarWinds*' -or $_.DisplayName -like 'SolarWinds*' -or $_.Name -like 'SW*'
  } | ForEach-Object {
    try { if ($_.Status -ne 'Stopped') { Stop-Service -Name $_.Name -Force -ErrorAction SilentlyContinue } } catch {}
  }

  # 2) Kill processes (quiet)
  Get-Process -ErrorAction SilentlyContinue | Where-Object {
    $_.Name -like 'SolarWinds*' -or $_.Name -like 'SW*'
  } | ForEach-Object {
    try { Stop-Process -Id $_.Id -Force -ErrorAction SilentlyContinue } catch {}
  }

  # 3) Discover installed SolarWinds products
  $uninstallHives = @(
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*',
    'HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*'
  )
  $patterns = '(?i)solarwinds|orion|sem|security event manager|log analyzer|engineer.s toolset|npm|sam|ipam|npm polling engine|solarwinds agent'
  foreach ($hive in $uninstallHives) {
    try { $FoundTargets += Get-ItemProperty -Path $hive -ErrorAction SilentlyContinue | Where-Object { $_.DisplayName -match $patterns } } catch {}
  }

  # 4) Uninstall (wait; quiet; never reboot)
  if ($FoundTargets) {
    foreach ($app in $FoundTargets) {
      $uninst = $app.UninstallString
      if (-not $uninst) { continue }

      $file = $null; $args = $null
      if ($uninst -match '(?i)msiexec') {
        # Normalize MSI to silent uninstall + no restart
        $args = $uninst -replace '(?i)msiexec\.exe','' -replace '(?i)/I','/X' -replace '(?i)/x','/X'
        if ($args -notmatch '(?i)/qn')        { $args = "$args /qn" }
        if ($args -notmatch '(?i)/norestart') { $args = "$args /norestart" }
        $file = "$env:WINDIR\System32\msiexec.exe"
      } else {
        # EXE uninstallers: keep existing args; add quiet + norestart
        if ($uninst.StartsWith('"')) {
          $file = $uninst.Substring(1, $uninst.IndexOf('"',1)-1)
          $args = $uninst.Substring($uninst.IndexOf('"',1)+1).Trim()
        } else {
          $parts = $uninst.Split(' ',2)
          $file  = $parts[0]
          $args  = if ($parts.Count -gt 1) { $parts[1] } else { "" }
        }
        if ($args -notmatch '(?i)/quiet|/qn|/silent|/s(?!e)') { $args = "$args /quiet" }
        if ($args -notmatch '(?i)/norestart')                 { $args = "$args /norestart" }
      }

      try {
        $p  = Start-Process -FilePath $file -ArgumentList $args -Wait -PassThru -ErrorAction Stop
        $ec = $p.ExitCode
        # Treat 3010 as success; ignore absent codes; mark others as non-fatal failure but continue cleanup
        if ($ec -ne 0 -and $ec -ne 3010 -and $ec -ne 1605 -and $ec -ne 1614 -and $ec -ne 1612) {
          if ($ExitCode -eq 0) { $ExitCode = 1 }
        }
      } catch { if ($ExitCode -eq 0) { $ExitCode = 1 } }
    }
  }

  # 5) Filesystem cleanup (after uninstall)
  foreach ($p in $GeneralPaths) {
    if (Test-Path $p) {
      try {
        Get-ChildItem -Path $p -Recurse -Force -ErrorAction SilentlyContinue | ForEach-Object { try { $_.Attributes='Normal' } catch {} }
        Remove-Item -Path $p -Recurse -Force -ErrorAction SilentlyContinue
      } catch {}
    }
  }

  foreach ($cpath in $CertFoldersFS) {
    if (Test-Path $cpath) {
      try {
        Get-ChildItem -Path $cpath -Force -ErrorAction SilentlyContinue | ForEach-Object {
          try { if (Test-Path $_.FullName) { $_.Attributes='Normal'; Remove-Item -Path $_.FullName -Recurse -Force -ErrorAction SilentlyContinue } } catch {}
        }
      } catch {}
    }
  }

  # 6) CertLM purge: LocalMachine -> "SolarWinds Agent" -> Certificates (remove items only)
  try {
    $store = New-Object System.Security.Cryptography.X509Certificates.X509Store('SolarWinds Agent', 'LocalMachine')
    $store.Open([System.Security.Cryptography.X509Certificates.OpenFlags]::ReadWrite)
    $certs = @($store.Certificates)
    if ($certs.Count -gt 0) {
      foreach ($c in $certs) { try { $store.Remove($c); $RemovedCerts++ } catch {} }
    }
    $store.Close()
  } catch {}

  # Double-check with provider path
  try {
    $provPath = 'Cert:\LocalMachine\SolarWinds Agent'
    if (Test-Path $provPath) {
      $provCerts = Get-ChildItem -Path $provPath -ErrorAction SilentlyContinue
      if ($provCerts) { foreach ($pc in $provCerts) { try { Remove-Item -Path $pc.PSPath -Force -ErrorAction SilentlyContinue; $RemovedCerts++ } catch {} } }
    }
  } catch {}

  # 7) Verify leftovers (dirs + cert store)
  foreach ($p in ($GeneralPaths + $CertFoldersFS)) { if (Test-Path $p) { $LeftoverDirs += $p } }

  try {
    $s = New-Object System.Security.Cryptography.X509Certificates.X509Store('SolarWinds Agent','LocalMachine')
    $s.Open([System.Security.Cryptography.X509Certificates.OpenFlags]::ReadOnly)
    $StoreLeft = $s.Certificates.Count
    $s.Close()
  } catch { $StoreLeft = 0 }

  if ($StrictCleanup -and ( ($LeftoverDirs.Count -gt 0) -or ($StoreLeft -gt 0) )) {
    $ExitCode = 2
  }

} catch {
  $ExitCode = 1
} finally {
  if ($TranscriptPath) { try { Stop-Transcript | Out-Null } catch {} }
  # Single, final summary line (explicitly includes StrictCleanup)
  $result = switch ($ExitCode) { 0 { 'SUCCESS' } 2 { 'SUCCESS_WITH_LEFTOVERS' } default { 'FAIL' } }
  Write-Host ("[SolarWinds-Uninstall] Result={0}; StrictCleanup={1}; Targets={2}; CertsRemoved={3}; LeftoverDirs={4}; StoreLeft={5}" -f $result, $StrictCleanup, ($FoundTargets.Count), $RemovedCerts, ($LeftoverDirs.Count), $StoreLeft)
  exit $ExitCode
}
