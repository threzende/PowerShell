# Definir a política de execução para 'Bypass' temporariamente
Set-ExecutionPolicy Bypass -Scope Process -Force

# Informações do programa que deseja desinstalar
$programName = "Networkr Client"
$programPublisher = "Dell EM"

# Caminho para o diretório e log
$directoryPath = "C:\Temp\thsfz"
$logPath = "$directoryPath\dellnetworkerlog.txt"
$serverListPath = "$directoryPath\serverz.txt"

# Verificar se a pasta C:\Temp\thsfz existe, caso contrário, criar
if (-not (Test-Path $directoryPath)) {
    New-Item -Path $directoryPath -ItemType Directory
}

# Função para escrever no log e no console
function Write-Log {
    param (
        [string]$message
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "$timestamp - $message"

    # Escrever no log
    Add-Content -Path $logPath -Value $logMessage

    # Escrever no console
    Write-Host $logMessage
}

# Verificar se o arquivo serverz.txt existe
if (-not (Test-Path $serverListPath)) {
    Write-Host "Arquivo de lista de servidores não encontrado em $serverListPath."
    exit
}

# Ler os servidores do arquivo serverz.txt
$servers = Get-Content -Path $serverListPath

# Função para desinstalar o programa via chave de registro
function Uninstall-Program {
    param (
        [string]$server
    )

    $uninstallKey = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
    $uninstallKey64 = "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall"

    $programFound = $false

    # Conectar-se ao registro remoto (chave 32-bit e 64-bit)
    foreach ($keyPath in @($uninstallKey, $uninstallKey64)) {
        $regPath = "HKLM:\$keyPath"
        try {
            $programs = Invoke-Command -ComputerName $server -ScriptBlock {
                param ($regPath)
                Get-ItemProperty -Path "Registry::$regPath\*" -ErrorAction SilentlyContinue
            } -ArgumentList $regPath | Where-Object { $_.DisplayName -eq $programName -and $_.Publisher -eq $programPublisher }

            if ($programs) {
                foreach ($program in $programs) {
                    $programFound = $true
                    $uninstallString = $program.UninstallString

                    # Verificar se a chave UninstallString existe
                    if ($uninstallString) {
                        Write-Log "Comando de desinstalação encontrado para $programName no servidor $server: $uninstallString"

                        # Executar o comando de desinstalação
                        Invoke-Command -ComputerName $server -ScriptBlock {
                            param ($uninstallString)
                            # Verificar se o comando de desinstalação é MSI ou EXE
                            if ($uninstallString -like "msiexec*") {
                                Write-Log "Executando MSI Uninstall no servidor"
                                & cmd.exe /c "$uninstallString /quiet /norestart"
                            } else {
                                Write-Log "Executando EXE Uninstall no servidor"
                                & cmd.exe /c "$uninstallString /quiet /norestart"
                            }
                        } -ArgumentList $uninstallString

                        Write-Log "Desinstalação do $programName no servidor $server concluída."
                    } else {
                        Write-Log "Chave de desinstalação (UninstallString) não encontrada para $programName no servidor $server."
                    }
                }
            }
        } catch {
            Write-Log "Erro ao acessar o registro no servidor $server. Detalhes: $_"
        }
    }

    if (-not $programFound) {
        Write-Log "Programa $programName não encontrado no servidor $server com Publisher $programPublisher."
    }
}

# Processar cada servidor da lista
foreach ($server in $servers) {
    Write-Log "Iniciando o processo de desinstalação no servidor $server..."
    Uninstall-Program $server
}

Write-Log "Processo de desinstalação concluído."
