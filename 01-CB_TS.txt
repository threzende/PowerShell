1 ###################################################################################


Pr√≥xima jogada (curta, ping-pong):
1) Confirma se existe sensor rodando
sc query confer
if exist "C:\Program Files\Confer\RepCLI.exe" "C:\Program Files\Confer\RepCLI.exe" status


Se existir, √© upgrade mesmo.

2) Tenta upgrade ‚Äúlimpo‚Äù como SYSTEM + c√≥digo
(se tiver PsExec)
psexec -i -s cmd.exe
msiexec /i C:\Windows\ccmcache\So\carbon_black-installer_vista_win7_win8-64-4.0.3.2029.msi /qn /l*v C:\Temp\cb_upgrade.log COMPANY_CODE=SEU_CODIGO UNINSTALL_CODE=CODIGO_DE_DESINSTALACAO


Se o sensor tiver tamper, sem UNINSTALL_CODE a remo√ß√£o falha em 1603.

3) Se preferir separar as etapas (tamb√©m como SYSTEM):
msiexec /x {CD18D792-3782-4E66-BD7A-E4E05C42BA86} /qn  UNINSTALL_CODE=CODIGO
msiexec /x {731A72EF-2920-4A2A-841E-486DF6105F8E} /qn  UNINSTALL_CODE=CODIGO
rd /s /q "C:\Program Files\Confer"
msiexec /i C:\Temp\rev1\CB\CB.msi /qn /l*v C:\Temp\cb_install2.log COMPANY_CODE=SEU_CODIGO


Os dois GUIDs aparecem no teu log; se algum voltar 1605 (n√£o instalado), ok.

Manda o resultado do sc query confer/repcli status ou me diz se conseguiu rodar como SYSTEM com UNINSTALL_CODE. A√≠ eu te digo o pr√≥ximo passo.


2 ###################################################################################

msiexec /x {731A72EF-2920-4A2A-841E-486DF6105F8E} /qn /l*v C:\Temp\cb_uninstall_guid1.log
echo %errorlevel%

3 ###################################################################################

msiexec /i C:\Windows\ccmcache\So\carbon_black-installer_vista_win7_win8-64-4.0.3.2029.msi REINSTALL=ALL REINSTALLMODE=amus /qn /l*v C:\Temp\cb_repair.log

4 ###################################################################################


msiexec /i "C:\Windows\ccmcache\So\carbon_black-installer_vista_win7_win8-64-4.0.3.2029.msi" /qn /l*v C:\Temp\cb_install3.log COMPANY_CODE=SEU_CODIGO


5 ############################################################################################

msiexec /x {CD18D792-3782-4E66-BD7A-E4E05C42BA86} /qn UNINSTALL_CODE=SEU_CODIGO /l*v C:\Temp\cb_un1.log
msiexec /x {731A72EF-2920-4A2A-841E-486DF6105F8E} /qn UNINSTALL_CODE=SEU_CODIGO /l*v C:\Temp\cb_un2.log


6 #########################################################################################

$paths = @(
 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*',
 'HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*'
)
Get-ItemProperty $paths |
  Where-Object {
    ($_.DisplayName -match 'Carbon|Confer|Cb Defense|CB Cloud|VMware Carbon' ) -or
    ($_.Publisher   -match 'VMware|Carbon Black')
  } |
  Select-Object DisplayName, DisplayVersion, Publisher, InstallLocation, UninstallString, PSChildName

7 #########################################################################################

$pat = 'carbon|confer|cbdefense|vmware.?carbon|vmware.?cb|bit9|parity'
'=== SERVICES ==='
Get-Service |
  Where-Object { $_.Name -match $pat -or $_.DisplayName -match $pat } |
  Select-Object Name, DisplayName, Status, StartType

'=== DRIVERS ==='
Get-CimInstance Win32_SystemDriver |
  Where-Object { ($_.Name -match $pat) -or ($_.DisplayName -match $pat) -or ($_.PathName -match $pat) } |
  Select-Object Name, DisplayName, State, StartMode, PathName

8 #########################################################################################

sc stop CbDefense
sc stop CbDefenseWSC
sc delete CbDefense
sc delete CbDefenseWSC

sc query type= service state= all | findstr /i cbdefense

9 #########################################################################################


sc stop CbDefense
sc stop CbDefenseWSC

reg delete "HKLM\SYSTEM\CurrentControlSet\Services\CbDefense" /f
reg delete "HKLM\SYSTEM\CurrentControlSet\Services\CbDefenseWSC" /f

reg delete "HKLM\SYSTEM\ControlSet001\Services\CbDefense" /f
reg delete "HKLM\SYSTEM\ControlSet001\Services\CbDefenseWSC" /f

reg delete "HKLM\SYSTEM\ControlSet002\Services\CbDefense" /f
reg delete "HKLM\SYSTEM\ControlSet002\Services\CbDefenseWSC" /f

10 #########################################################################################

# 1) parar e deletar os servi√ßos, se existirem
$svcs = 'CbDefense','CbDefenseWSC'
foreach ($s in $svcs) {
  $svc = Get-Service -Name $s -ErrorAction SilentlyContinue
  if ($svc) {
    try { Stop-Service -Name $s -Force -ErrorAction SilentlyContinue } catch {}
    & sc.exe delete $s | Out-Null
  }
}

# 2) apagar as chaves de servi√ßo em todos os ControlSets (se existirem)
$paths = @(
  'HKLM:\SYSTEM\CurrentControlSet\Services\CbDefense',
  'HKLM:\SYSTEM\CurrentControlSet\Services\CbDefenseWSC',
  'HKLM:\SYSTEM\ControlSet001\Services\CbDefense',
  'HKLM:\SYSTEM\ControlSet001\Services\CbDefenseWSC',
  'HKLM:\SYSTEM\ControlSet002\Services\CbDefense',
  'HKLM:\SYSTEM\ControlSet002\Services\CbDefenseWSC'
)
foreach ($p in $paths) {
  if (Test-Path $p) { Remove-Item -Path $p -Recurse -Force }
}

# 3) mostrar se sobrou algo
'=== Servi√ßos restantes ==='
Get-Service | Where-Object {$_.Name -match 'CbDefense'} | Select-Object Name,Status,StartType

11 #########################################################################################

Get-CimInstance Win32_Service -Filter "Name='CbDefense'"     | Remove-CimInstance -ErrorAction SilentlyContinue
Get-CimInstance Win32_Service -Filter "Name='CbDefenseWSC'"  | Remove-CimInstance -ErrorAction SilentlyContinue

# conferir
sc.exe query type= service state= all | findstr /i cbdefense

12 #########################################################################################


# 1) Congelar quem recria
Stop-Service ccmexec -Force -ErrorAction SilentlyContinue
Set-Service  ccmexec -StartupType Disabled -ErrorAction SilentlyContinue
Get-Process msiexec -ErrorAction SilentlyContinue | Stop-Process -Force

# 2) Remover servi√ßos (SCM + WMI)
'-- remove via SCM'
& sc.exe delete CbDefense       | Out-Null
& sc.exe delete CbDefenseWSC    | Out-Null
'-- remove via WMI'
Get-CimInstance Win32_Service -Filter "Name='CbDefense'"     | Remove-CimInstance -ErrorAction SilentlyContinue
Get-CimInstance Win32_Service -Filter "Name='CbDefenseWSC'"  | Remove-CimInstance -ErrorAction SilentlyContinue

# 3) Apagar chaves de servi√ßo em TODOS os ControlSets
$svcKeys = @(
 'HKLM:\SYSTEM\CurrentControlSet\Services\CbDefense',
 'HKLM:\SYSTEM\CurrentControlSet\Services\CbDefenseWSC',
 'HKLM:\SYSTEM\ControlSet001\Services\CbDefense',
 'HKLM:\SYSTEM\ControlSet001\Services\CbDefenseWSC',
 'HKLM:\SYSTEM\ControlSet002\Services\CbDefense',
 'HKLM:\SYSTEM\ControlSet002\Services\CbDefenseWSC'
)
foreach ($k in $svcKeys) { if (Test-Path $k) { Remove-Item $k -Recurse -Force } }

# 4) Apagar LEGACY_* (precisa tomar posse das chaves Enum)
function Remove-EnumLegacy($name){
  $p = "HKLM:\SYSTEM\CurrentControlSet\Enum\Root\$name"
  if (Test-Path $p) {
    & reg.exe add "HKLM\SYSTEM\CurrentControlSet\Enum\Root" /v "TMP" /t REG_SZ /d "x" /f | Out-Null
    & reg.exe delete ("HKLM\SYSTEM\CurrentControlSet\Enum\Root\" + $name) /f
  }
}
Remove-EnumLegacy -name 'LEGACY_CbDefense'
Remove-EnumLegacy -name 'LEGACY_CbDefenseWSC'

# 5) Verificar se ainda existe algo
'=== Servi√ßos restantes ==='
& sc.exe query type= service state= all | Select-String -Pattern 'CbDefense'

13 #########################################################################################

O que eu faria agora (1‚Äì2 passos no ping-pong):

Start + eventos + log (pega o erro real):

sc start CbDefense
Get-WinEvent -FilterHashtable @{LogName='System'; Id=@(7000,7009,7031,7034); StartTime=(Get-Date).AddMinutes(-10)} |
  Select TimeCreated, Id, Message
Get-Content "C:\Program Files\Confer\confer.log" -Tail 80


Teste de rede (pra eliminar proxy/SSL):

Test-NetConnection cloud.carbonblack.com -Port 443
Test-NetConnection defense.conferdeploy.net -Port 443


(se usar proxy, me diga qual tipo/host/porta)

Se vier 7000/7009 (timeout) sem erro de rede no confer.log, sobe o ServicesPipeTimeout e reinicia:

New-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Control' -Name ServicesPipeTimeout -PropertyType DWord -Value 120000 -Force
Restart-Computer

14 #########################################################################################


# === Ajuste seus valores ===
$msi  = 'C:\Windows\ccmcache\So\carbon_black-installer_vista_win7_win8-64-4.0.3.2029.msi'
$log  = 'C:\Temp\cb_repair_again.log'
$code = 'SEU_CODIGO'   # COMPANY_CODE

# === Preparar ===
New-Item -ItemType Directory -Path (Split-Path $log) -Force | Out-Null
$taskName = 'CB_RepairOnce_' + ([guid]::NewGuid().ToString('N'))

# === Criar tarefa agendada rodando como SYSTEM (Highest) ===
$action     = New-ScheduledTaskAction -Execute 'msiexec.exe' -Argument "/fvamus `"$msi`" /qn /l*v `"$log`" COMPANY_CODE=$code"
$principal  = New-ScheduledTaskPrincipal -UserId 'SYSTEM' -RunLevel Highest
$settings   = New-ScheduledTaskSettingsSet -StartWhenAvailable -Compatibility Win8
$task       = New-ScheduledTask -Action $action -Principal $principal -Settings $settings
Register-ScheduledTask -TaskName $taskName -InputObject $task | Out-Null

# === Rodar e esperar ===
Start-ScheduledTask -TaskName $taskName
# espera at√© a tarefa finalizar (timeout 10 min)
$deadline = (Get-Date).AddMinutes(10)
do {
  Start-Sleep 2
  $state = (Get-ScheduledTask -TaskName $taskName).State
} while ($state -eq 'Running' -and (Get-Date) -lt $deadline)

# coleta resultado e limpa a tarefa
$last = Get-ScheduledTaskInfo -TaskName $taskName
Unregister-ScheduledTask -TaskName $taskName -Confirm:$false

# === Verifica√ß√£o p√≥s-repair ===
"TaskLastRunTime: $($last.LastRunTime)  LastTaskResult: $($last.LastTaskResult)"
"RepCLI exists? " + (Test-Path 'C:\Program Files\Confer\RepCLI.exe')

15 #########################################################################################

Get-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\* | 
Where-Object { $_.DisplayName -match 'Visual C\+\+' -or $_.DisplayName -match 'Net Framework' } | 
Select-Object DisplayName, DisplayVersion | 
Sort-Object DisplayName

16 #########################################################################################

$action = "New-ScheduledTaskAction -Execute 'Msiexec.exe' -Argument '/fvamus "$fvamus" /qn /l*v "$slog" COMPANY_CODE="$scode"'"

Get-CimInstance -ClassName Win32_Product | 
Where-Object { $_.Name -match 'antivirus' -or $_.Name -match 'security' -or $_.Name -match 'endpoint' } | 
Select-Object Name

Get-MpComputerStatus | Select-Object AntivirusEnabled, RealTimeProtectionEnabled

17 #########################################################################################

# ====================================================================
# ATEN√á√ÉO: SUBSTITUA OS VALORES ABAIXO PELOS CORRETOS ANTES DE EXECUTAR!
# ====================================================================

# 1. Caminho completo para o instalador .msi do Carbon Black (Confirmado por voc√™)
$fvamus = "C:\temp\cb\cb.msi" 

# 2. C√≥digo da sua empresa (Company Code) - VOC√ä PRECISA MUDAR ESTE VALOR!
$scode = "SEU_CODIGO_DA_EMPRESA_AQUI" 

# 3. Nome do Grupo (GROUP_NAME) - VOC√ä PRECISA MUDAR ESTE VALOR!
$group = "NOME_DO_GRUPO_NA_CONSOLE_CB"

# ====================================================================

# Vari√°veis de Controle e Log
$TaskName = "CBInstallTest_Final"
# Caminho do Log: O LOG ESTAR√Å AQUI! C:\Windows\Temp\CB_LOG_TEST.log
$slog_path = "C:\Windows\Temp\CB_LOG_TEST.log"
# Argumentos de instala√ß√£o: /i (Instalar) /qn (Quiet No UI) /l*v (Log Verbose)
# Adicionado GROUP_NAME!
$msi_arguments = "/i `"$fvamus`" /qn /l*v `"$slog_path`" COMPANY_CODE=`"$scode`" GROUP_NAME=`"$group`""

# 1. Defini√ß√£o da A√ß√£o 
$action = New-ScheduledTaskAction -Execute 'C:\Windows\System32\msiexec.exe' -Argument $msi_arguments

# 2. Cria√ß√£o da Tarefa Agendada rodando como SYSTEM (Highest)
$principal = New-ScheduledTaskPrincipal -UserID 'SYSTEM' -RunLevel Highest
$settings = New-ScheduledTaskSettingsSet -StartWhenAvailable -Compatibility Win8
$task = New-ScheduledTask -Action $action -Principal $principal -Settings $settings 
Register-ScheduledTask -TaskName $TaskName -InputObject $task | Out-Null

Write-Host "Iniciando a tarefa agendada '$TaskName'..."
Start-ScheduledTask -TaskName $TaskName 

# 3. Espera o t√©rmino da tarefa (Timeout 10 min)
$deadline = (Get-Date).AddMinutes(10)
do {
    Start-Sleep 2
    $state = (Get-ScheduledTask -TaskName $TaskName).State
} while ($state -eq 'Running' -and (Get-Date) -lt $deadline)

# 4. Coleta o resultado
$last = Get-ScheduledTaskInfo -TaskName $TaskName
Unregister-ScheduledTask -TaskName $TaskName -Confirm:$false

# 5. Exibe o resultado e a localiza√ß√£o do Log
Write-Host "---"
Write-Host "‚úÖ TAREFA CONCLU√çDA"
Write-Host "Resultado da Tentativa: $($last.LastTaskResult)" 
Write-Host "üö® O LOG DETALHADO EST√Å EM: $slog_path"
Write-Host "---"

18 #########################################################################################